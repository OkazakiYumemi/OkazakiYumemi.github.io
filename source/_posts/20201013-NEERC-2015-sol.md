---
title: NEERC 2015 选做
categories: 题解
urlname: GYM100851
date: 2020-10-13 21:21:54
tags:
- GYM
top: 1
---

集训队作业开冲。
[2015-2016 ACM-ICPC Northeastern European Regional Contest (NEERC 15)](https://codeforces.com/gym/100851)

- [x] B - Binary vs Decimal
- [ ] C - Cactus Jubilee
- [ ] D - Distance on Triangulation
- [ ] H - Hypercube
- [ ] I - Iceberg Orders
- [ ] J - Jump
- [ ] K - King’s Inspection
- [ ] L - Landscape Improved

<!-- more -->

## B - Binary vs Decimal

### 题意简述

求第 $n$ 小的正整数 $A$ 满足：
- $A$ 中仅含`0`,`1`。
- 设 $A$ 的二进制表示为 $B$，则 $A$ 为 $B$ 的后缀。

$n\le 10000$。

### 主要思路

{% fold 我会暴力判断！ %}
```py
def check(i):
    x = int(bin(i)[2:])
    xbs = str(bin(x)[2:])
    x = str(x)
    y = xbs[-len(x):]
    if x == y: return True
    return False

fin = open("binary.in", "r")
rd = int(fin.read())
fin.close()

Q = [0, 1]
lim = 1

while len(Q) <= rd:
    lim *= 2
    P = []
    for x in Q:
        y = x + lim
        if check(y):
            P.append(y)
    Q += P

# for x in Q:
#     print(x, end = ', ')

fout = open("binary.out", "w")
fout.write(bin(Q[rd])[2:])
fout.close()
```
{% endfold %}

然而显然这样是过不去的。
打了个表，好像也没啥性质。

后来发现如果 $A$ 合法，则 $A$ 的任意一个后缀都合法。
于是写个高精 bfs 就好了。

### 参考代码

{% fold %}
```cpp
#include <bits/stdc++.h>
namespace my_std {
using namespace std;
#define reg register
#define Rint register int
#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)
#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)
#define Templ(T) template <typename T>
Templ(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }
Templ(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }
} // namespace my_std
using namespace my_std;

typedef unsigned long long u64;
typedef unsigned int u32;

#define BM 4
struct BigNum{
    u64 a[BM];
    inline void reset(){ FOR(i, 0, BM - 1) a[i] = 0; }
    inline void set(){ FOR(i, 0, BM - 1) a[i] = ~0ull; }
    inline BigNum(){ reset(); }
    inline void reset(const int &x){ a[x >> 6] &= ~(1ull << (x & 63)); }
    inline void set(const int &x){ a[x >> 6] |= 1ull << (x & 63); }
    inline bool test(const int &x)const{ return (a[x >> 6] >> (x & 63)) & 1; }
    inline BigNum operator <<(const int &x)const{//x must be in [0, 64)
        reg BigNum res;
        reg u64 t = 0;
        FOR(i, 0, BM - 1){
            res.a[i] = (a[i] << x) | t;
            t = a[i] >> (64 - x);
        }
        return res;
    }
    inline BigNum operator +(const BigNum &rhs)const{
        reg BigNum res;
        reg bool t = 0;
        FOR(i, 0, BM - 1){
            if(t){
                res.a[i] = a[i] + rhs.a[i] + 1;
                if(a[i] < ~0ull - rhs.a[i]) t = 0;
                else t = 1;
            }else{
                res.a[i] = a[i] + rhs.a[i];
                if(a[i] <= ~0ull - rhs.a[i]) t = 0;
                else t = 1;
            }
        }
        return res;
    }
}m10[256], Q[16384], P[16384];
int qt = 1;

inline void print(const BigNum &x){
    Rint t = 255;
    for(; !x.test(t); --t);
    for(; ~t; --t) putchar(int(x.test(t)) ^ 48);
    putchar(10);
}
inline bool check(const BigNum &x, const BigNum &y){
    Rint t = 255;
    for(; !x.test(t); --t);
    for(; ~t; --t) if(x.test(t) ^ y.test(t)) return 0;
    return 1;
}

int main() {
    freopen("binary.in", "r", stdin);
    freopen("binary.out", "w", stdout);
    
    m10[0].set(0);
    FOR(i, 1, 255) m10[i] = (m10[i - 1] << 3) + (m10[i - 1] << 1);

    int n;
    scanf("%d", &n);

    Q[1].set(0);
    P[1].set(0);

    Rint lim = 0;
    while(qt <= n){
        ++lim;
        FOR(i, 0, qt){
            reg BigNum x = Q[i], y = P[i];
            x.set(lim);
            y = y + m10[lim];
            if(check(x, y)){
                Q[++qt] = x;
                P[qt] = y;
            }
        }
    }

    print(Q[n]);
    // FOR(i, 1, n) print(Q[i]);
    return 0;
}
```
{% endfold %}