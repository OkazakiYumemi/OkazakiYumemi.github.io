---
title: 多项式板子
date: 2020-06-24 21:17:12
tags:
- 卡常
- 多项式
categories: 算法
top:
urlname: 多项式板子
---

某一天发现自己的多项式板子好像全机房最慢唉。

于是找了些博客来学习卡常。

然后喜提目前全机房最快。

<!-- more -->

### 如何卡常

#### 取模优化

众所周知 C++ 取模慢得出奇，想优化常数，自然而然想到在取模上下工夫。

曾经为了避免加减取模写了这样的东西：

```cpp
const int mod = 998244353;
inline void inc(int &x, const int &y){if((x += y) >= mod) x -= mod;}
inline void dec(int &x, const int &y){if((x -= y) < 0) x += mod;}
```

后来发现加一加减一减比一比也挺慢，于是就有了这样的东西：

```cpp
const int mod = 998244353;
inline int qmo(const int &x){return x + ((x >> 31) & mod);}
```

大概就是用了下对`int`型右移 31 位会使其全部变成符号位的性质。

#### 预处理原根

每次还要根据长度重新处理蝴蝶变换的数组？这里要做大量的乘法和取模，不如直接一次处理出来优化常数。

预处理要 $O(n\log n)$？长度总是 2 的次幂，完全可以只用 $O(n)$。

#### 清空与移动数组

`memset`与`memcpy`无论是否在`-O2`下都有优秀的表现。

#### DFT时使用64位无符号整数

稍微算算，发现在模数是`int`范围内是不会爆`unsigned long long`的。

无符号整数在做加减乘的时候会稍微快一些。

### 模板

```cpp
#include <bits/stdc++.h>
namespace my_std {
using namespace std;
#define reg register
#define Rint register int
#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)
#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)
#define FORit(templ, arr, i, a, b) \
for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)
#define ROFit(templ, arr, i, a, b) \
for (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)
#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)
#define fir first
#define sec second
#define pq priority_queue
#define MP make_pair
typedef unsigned int uint;
typedef long long LL;
typedef unsigned long long uLL;
typedef double DB;
typedef pair<int, int> PII;
#define Templ(T) template <typename T>
#ifdef LOCAL
#define gcr() getchar()
#define pcr(x) putchar(x)
#define F_In void()
#define F_Out void()
#else
static char InB[1 << 21], *In_s = InB;
static char OutB[1 << 21], *Out_s = OutB;
#define gcr() (*In_s ++)
#define pcr(x) (*Out_s ++ = x)
#define F_In (fread(InB, 1, 1 << 21, stdin))
#define F_Out (fwrite(OutB, 1, Out_s - OutB, stdout), Out_s = OutB)
#endif
inline int read() {
    // reg int ans = 0, f = 1;
    reg int ans = 0;
    reg char c = gcr();
    // while (!isdigit(c)) f ^= (c == '-'), c = gcr();
    while (!isdigit(c)) c = gcr();
    for (; isdigit(c); c = gcr()) ans = (ans << 1) + (ans << 3) + (c ^ 48);
    // return f ? ans : -ans;
    return ans;
}
inline void write(int x){
    static int sta[12];
    // if(x < 0) return pcr('-'), write(-x);
    Rint top = 0;
    do{
        sta[top ++] = x % 10, x /= 10;
    }while(x);
    while(top) pcr(sta[-- top] ^ 48);
}
Templ(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }
Templ(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }
#define using_mod
const int mod = 998244353;
#ifdef using_mod
inline void inc(int &x, const int &y) { if ((x += y) >= mod) x -= mod; }
inline void dec(int &x, const int &y) { if ((x -= y) < 0) x += mod; }
inline int ksm(int x, int y) {
    reg int res = 1;
    for (; y; y >>= 1, x = 1ll * x * x % mod)
        if (y & 1) res = 1ll * res * x % mod;
    return res;
}
inline int qmo(const int &x){
    return x >> 31 ? x + mod : x;
}
#endif
Templ(_Tp) inline _Tp gcd(_Tp x, _Tp y) { return y ? gcd(y, x % y) : x; }
#define FILE(s) freopen(s ".in", "r", stdin), freopen(s ".out", "w", stdout)
#define PBTXDY
} // namespace my_std
using namespace my_std;

#define swap(x, y) (x ^= y ^= x ^= y)
// const int N = 270010;
const int N = 2100010;

int LMT = 1;
int rev[N], omg[N], inv[N];
int l2g[N];
inline void init(const int &n){
    inv[1] = 1;
    FOR(i, 2, n) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;
    l2g[1] = 0;
    FOR(i, 2, n << 1){
        l2g[i] = l2g[i >> 1] + 1;
    }
}

inline int get_len(const int &n){
    return 1 << (l2g[n] + 1);
}

inline void poly_init(const int &n){
    Rint l = 0;
    while(LMT <= n) LMT <<= 1, ++ l;
    FOR(i, 1, LMT - 1) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
    reg const int t = ksm(3, (mod - 1) >> l);
    omg[LMT >> 1] = 1;
    FOR(i, (LMT >> 1) + 1, LMT - 1) omg[i] = (LL)omg[i - 1] * t % mod;
    ROF(i, (LMT >> 1) - 1, 1) omg[i] = omg[i << 1];
    LMT = l;
}

inline void DFT(int *a, const int &n){
    // static LL tmp[N];
    static uLL tmp[N];
    reg const int fix = LMT - l2g[n];
    Rint t;
    FOR(i, 0, n - 1) tmp[i] = a[rev[i] >> fix];
    for(Rint i = 1; i < n; i <<= 1){
        for(Rint j = 0; j < n; j += i << 1){
            FOR(k, j, j + i - 1){
                t = tmp[i + k] * omg[i + k - j] % mod;
                // tmp[i + k] = qmo(tmp[k] - t);
                // tmp[k] = qmo(tmp[k] - mod + t);
                tmp[i + k] = tmp[k] + mod - t;
                tmp[k] += t;
            }
        }
    }
    FOR(i, 0, n - 1) a[i] = tmp[i];
}
inline void IDFT(int *a, const int &n){
    reverse(a + 1, a + n);
    DFT(a, n);
    reg const int bk = mod - (mod - 1) / n;
    FOR(i, 0, n - 1) a[i] = (LL)a[i] * bk % mod;
}

//c <- a * b
inline void poly_mul(int *a, int *b, int *c, const int &deg){
    static int tmp1[N], tmp2[N];
    reg const int len = get_len(deg);
    memcpy(tmp1, a, sizeof(int) * len), memcpy(tmp2, b, sizeof(int) * len);
    DFT(tmp1, len), DFT(tmp2, len);
    FOR(i, 0, len - 1) c[i] = (LL)tmp1[i] * tmp2[i] % mod;
    IDFT(c, len);
}
//b <- a ^ (-1)
inline void poly_inv(int *a, int *b, const int &deg){
	static int tmp[N];
	if(deg == 1){
		b[0] = ksm(a[0], mod - 2);
		return;
	}
	poly_inv(a, b, (deg + 1) >> 1);
	reg const int len = get_len(deg << 1);
	memcpy(tmp, a, sizeof(int) * deg);
	memset(tmp + deg, 0, sizeof(int) * (len - deg));
	DFT(b, len), DFT(tmp, len);
	FOR(i, 0, len - 1){
		b[i] = (LL)qmo(2 - (LL)b[i] * tmp[i] % mod) * b[i] % mod;
	}
	IDFT(b, len);
	memset(b + deg, 0, sizeof(int) * (len - deg));
}
//b(x) <- \d a(x) / \d x
inline void poly_der(int *a, int *b, const int &deg){
	FOR(i, 0, deg - 2) b[i] = (LL)a[i + 1] * (i + 1) % mod;
	b[deg - 1] = 0;
}
//b(x) <- \int a(x) \d x
inline void poly_int(int *a, int *b, const int &deg){
	FOR(i, 1, deg - 1) b[i] = (LL)a[i - 1] * inv[i] % mod;
	b[0] = 0;
}
//b <- \ln a
inline void poly_ln(int *a, int *b, const int &deg){
	static int tmp[N];
	poly_inv(a, tmp, deg);
	poly_der(a, b, deg);
	reg const int len = get_len(deg << 1);
	DFT(b, len), DFT(tmp, len);
	FOR(i, 0, len - 1) tmp[i] = (LL)tmp[i] * b[i] % mod;
	IDFT(tmp, len);
	poly_int(tmp, b, deg);
	memset(b + deg, 0, sizeof(int) * (len - deg));
	memset(tmp, 0, sizeof(int) * len);
}
//b <- \exp a
inline void poly_exp(int *a, int *b, const int &deg){
	static int tmp[N];
	if(deg == 1){
		b[0] = 1;
		return;
	}
	poly_exp(a, b, (deg + 1) >> 1);
	poly_ln(b, tmp, deg);
	reg const int len = get_len(deg << 1);
	FOR(i, 0, len - 1){
		if(i < deg) tmp[i] = qmo(a[i] - tmp[i]);
		else tmp[i] = 0;
	}
	++tmp[0];
	DFT(b, len), DFT(tmp, len);
	FOR(i, 0, len - 1){
		b[i] = (LL)tmp[i] * b[i] % mod;
	}
	IDFT(b, len);
	memset(b + deg, 0, sizeof(int) * (len - deg));
	memset(tmp + deg, 0, sizeof(int) * (len - deg));
}

int main() {
    F_In;
    F_Out;
    return 0;
}
```

即使在你谷巨慢的评测机下都能够跑过机房其他人在你谷评测机还没那么慢的时候跑的 exp 。

### 参考资料

[yurzhang's blog](https://nikaidou-shinku.github.io/【题解】-Luogu5494-多项式双曲函数/)