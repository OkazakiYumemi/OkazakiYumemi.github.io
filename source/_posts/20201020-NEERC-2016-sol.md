---
title: NEERC 2016 选做
categories: 题解
urlname: GYM101190
date: 2020-10-20 21:03:39
tags:
- GYM
top: 1
---

>Q：弟啊你 NEERC 2015 咋还没做完呢
>A：咕了（指太菜看不懂题解）

[2016-2017 ACM-ICPC Northeastern European Regional Contest (NEERC 16)](https://codeforces.com/gym/101190)

- [ ] B - Binary Code
- [ ] C - Cactus Construction
- [ ] D - Delight for a Cat
- [x] G - Game on Graph
- [ ] I - Indiana Jones and the Uniform Cave
- [x] K - Kids Designing Kids
- [x] L - List of Primes
- [x] M - Mole Tunnels

<!-- more -->

## G - Game on Graph

### 题意简述

一张有向图，两人`0`,`1`在玩游戏。游戏规则非常简单：图上有一棋子，两人轮流操作，每人每次将棋子沿当前位置的某条出边移动，不能动的人就输了。
但是由于一些特殊原因，`0`最希望游戏永远不要停止；若无法达到，其也会尽可能追求赢。`1`最不希望游戏永远不停止；若可以使游戏停止，其宁愿输。
现在请对于每个点作为棋子的开始点，每个人作为先手，求最后的状态是什么（赢/输/无法结束）。
$n\le 10^5, m\le 2\times 10^5$。

### 主要思路

设一个游戏状态为一个二元组 $(x, c)$ 表示当前棋子在点 $x$，此时操作的是 $c$。
`0`若`1`无论如何操作都可以使游戏无法结束，他就会令游戏无法结束；否则`1`会阻止游戏无法结束。
`1`若`0`无论如何操作都可以自己赢，那他会使自己赢；否则`0`会阻止`1`赢。
而其余的情况，`0`会赢。

考虑清楚这一点之后，就可以设 $ending(x, c), winning(x, c)$ 分别表示 $(x, c)$ 状态能否结束、`1`能否赢。

考虑用反向 bfs 来求 $ending$。
首先，显然对于所有没有出度的状态 $(x, c)$，它们均能结束。把这些状态全扔队列里。
考虑 $(x, 1)$ 如何能够结束：只要它的下一个可能状态中有一个可以结束，它就能结束；
而 $(x, 0)$ 要结束，必须要它的每一个下一个可能状态都可以结束。

同样用反向 bfs 来求 $winning$，可以发现转移方式完全一致。

### 参考代码

{% fold %}
```cpp
#include <bits/stdc++.h>
namespace my_std {
using namespace std;
#define reg register
#define Rint register int
#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)
#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)
typedef pair<int, int> PII;
typedef vector<int> VI;
#define pb emplace_back
#define fr first
#define sc second
#define MP make_pair
#define Templ(T) template <typename T>
Templ(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }
Templ(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }
} // namespace my_std
using namespace my_std;

#define MMR (1 << 23)
struct INPUT{
    FILE *F;
    char buf[MMR], *s, *t;
    INPUT(): F(fopen("game.in", "r")){
        t = (s = buf) + fread(buf, 1, MMR, F);
        fclose(F);
    }
    Templ(_Tp) inline INPUT& operator >>(_Tp &x){
        x = 0;
        reg char c(*s++);
        while(c < 48) c = *s++;
        while(c > 47) x = x * 10 + c - 48, c = *s++;
        return *this;
    }
}fin;
struct OUTPUT{
    FILE *F;
    char buf[MMR], *s;
    OUTPUT(): F(fopen("game.out", "w")){ s = buf; }
    inline OUTPUT& operator <<(int x){
        static int tmp[10];
        Rint *top = tmp;
        do{
            *++top = (x % 10) ^ 48, x /= 10;
        }while(x);
        while(top != tmp) *s++ = *top--;
        *s++ = 32;
        return *this;
    }
    inline OUTPUT& operator <<(char x){
        *s++ = x;
        return *this;
    }
    ~OUTPUT(){
        fwrite(buf, 1, s - buf, F);
        fclose(F);
    }
}fout;

//0: D - W - L
//1: W - L - D

#define N 100010
int n, m;
VI to[N], fm[N];
//正向边 / 反向边
int oud[N];

inline void init(){
    fin >> n >> m;
    Rint u, v;
    FOR(i, 1, m){
        fin >> u >> v;
        to[u].pb(v);
        fm[v].pb(u);
    }
}

queue<PII> Q;
inline void work(bool (*f)[2]){
    FOR(i, 1, n) oud[i] = to[i].size();
    FOR(i, 1, n) FOR(c, 0, 1) if(f[i][c]) Q.push(MP(i, c));
    while(!Q.empty()){
        PII now = Q.front();
        Q.pop();
        Rint u = now.fr;
        if(now.sc){
            for(int v: fm[u]) if(!f[v][0] && !--oud[v]){
                f[v][0] = 1;
                Q.push(MP(v, 0));
            }
        }else{
            for(int v: fm[u]) if(!f[v][1]){
                f[v][1] = 1;
                Q.push(MP(v, 1));
            }
        }
    }
}

bool endable[N][2], winning[N][2];
//endable[u][c]: 从 u 开始、c 先手时，1 是否能令其结束
//winning[u][c]: 从 u 开始、c 先手时，1 能否胜出

int main() {
    init();
    FOR(i, 1, n) if(to[i].empty())
        endable[i][0] = endable[i][1] = winning[i][0] = 1;
    work(endable);
    work(winning);
    FOR(i, 1, n){
        if(!endable[i][0]) fout << 'D';
        else if(winning[i][0]) fout << 'L';
        else fout << 'W';
    }
    fout << '\n';
    FOR(i, 1, n){
        if(winning[i][1]) fout << 'W';
        else if(endable[i][1]) fout << 'L';
        else fout << 'D';
    }
    return 0;
}
```
{% endfold %}

## K - Kids Designing Kids

## L - List of Primes

### 题意简述

## M - Mole Tunnels

### 题意简述

### 主要思路

### 参考代码

{% fold %}
{% endfold %}