---
title: NEERC 2016 选做
categories: 题解
urlname: GYM101190
date: 2020-10-20 21:03:39
tags:
- GYM
top: 1
---

>Q：弟啊你 NEERC 2015 咋还没做完呢
>A：咕了（指太菜看不懂题解）

[2016-2017 ACM-ICPC Northeastern European Regional Contest (NEERC 16)](https://codeforces.com/gym/101190)

- [ ] B - Binary Code
- [x] C - Cactus Construction
- [ ] D - Delight for a Cat
- [x] G - Game on Graph
- [ ] I - Indiana Jones and the Uniform Cave
- [x] K - Kids Designing Kids
- [x] L - List of Primes
- [x] M - Mole Tunnels

<!-- more -->

## C - Cactus Construction

### 题意简述

给定一棵仙人掌（$n\le 5\times 10^5$），你需要构造它。
初始时，每个点颜色都为`1`，每个点都是仅有一个点的子图。
你有三种操作：
1. $join(u, v)$：把子图 $v$ 合并进子图 $u$。
2. $connect(u, a, b)$：把子图 $u$ 中颜色为 $a$ 的所有点与颜色为 $b$ 的所有点连边。
   注意若原本存在颜色 $a$ 的点与颜色 $b$ 的点之间有边，会连出重边，然而众所周知仙人掌是没有重边的，所以要避免这种情况。
3. $recolor(u, a, b)$：把子图 $u$ 中颜色为 $a$ 的所有点改为颜色 $b$。

假设你的操作数量是 $m$，操作间出现过的颜色数量是 $c$，那么你需要保证 $m\le 10^6, c\le 4$。

### 主要思路

考虑树怎么做。从下往上合并，保证子树内只有根的颜色是 $2$，其他都是 $1$。合并一个儿子的时候把儿子改成颜色 $3$，合并连上后，再把颜色 $3$ 改成 $1$。
考虑环怎么做。我们选定一个「根」，那么剩下的部分就是一条链。我们把链头染成颜色 $2$，在接入下一个点时选择一个链上当前未出现的颜色 $c$，把新接入的点染成该色，再把另一色的原本的链尾和新接入的点连边，再把原本的链尾改成颜色 $1$ 即可。

### 参考代码

{% fold %}
```cpp
#include <bits/stdc++.h>
namespace my_std {
using namespace std;
#define reg register
#define Rint register int
#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)
#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)
typedef pair<int, int> PII;
typedef vector<int> VI;
#define SZ(x) ((int)x.size())
#define pb emplace_back
#define Templ(T) template <typename T>
Templ(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }
Templ(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }
} // namespace my_std
using namespace my_std;

#define MMR (1 << 23)
struct INPUT{
    FILE *F;
    char buf[MMR], *s, *t;
    INPUT(): F(fopen("cactus.in", "r")){
        t = (s = buf) + fread(buf, 1, MMR, F);
        fclose(F);
    }
    Templ(_Tp) inline INPUT& operator >>(_Tp &x){
        x = 0;
        reg char c(*s++);
        while(c < 48) c = *s++;
        while(c > 47) x = x * 10 + c - 48, c = *s++;
        return *this;
    }
}fin;
struct OUTPUT{
    FILE *F;
    char buf[MMR], *s;
    OUTPUT(): F(fopen("cactus.out", "w")){ s = buf; }
    inline OUTPUT& operator <<(int x){
        static int tmp[10];
        Rint *top = tmp;
        do{
            *++top = (x % 10) ^ 48, x /= 10;
        }while(x);
        while(top != tmp) *s++ = *top--;
        return *this;
    }
    inline OUTPUT& operator <<(char x){
        *s++ = x;
        return *this;
    }
    ~OUTPUT(){
        fwrite(buf, 1, s - buf, F);
        fclose(F);
    }
}fout;

struct qry{
    int t, a, b, c;
    inline qry(int _t, int _a, int _b, int _c)
        : t(_t), a(_a), b(_b), c(_c){}
};
vector<qry> ans;
#define join(a, b) ans.pb(qry(0, a, b, 0))
#define recolor(a, b, c) ans.pb(qry(1, a, b, c))
#define connect(a, b, c) ans.pb(qry(2, a, b, c))
inline void print_ans(){
    fout << SZ(ans) << '\n';
    for(reg qry x: ans){
        if(!x.t) fout << 'j' << ' ' << x.a << ' ' << x.b << '\n';
        else fout << "rc"[x.t - 1] << ' ' << x.a << ' ' << x.b << ' ' << x.c << '\n';
    }
}

#define N 100010
int n, m;
VI E[N], T[N];

namespace Tarjan{
int dfn[N], low[N], pc, cc;
int sk[N], *st(sk);
void dfs(const int &u){
    dfn[u] = low[u] = ++ pc;
    *++st = u;
    for(Rint v: E[u]){
        if(!dfn[v]){
            dfs(v), chkmin(low[u], low[v]);
            if(low[v] >= dfn[u]){
                ++cc, T[u].pb(cc);
                do{
                    T[cc].pb(*st);
                }while(*st-- != v);
            }
        }else{
            chkmin(low[u], dfn[v]);
        }
    }
}
int main(){
    cc = n;
    dfs(1);
    return 0;
}
}

int id[N];

void dfs(const int &u){
    if(u <= n){
        id[u] = u;
        recolor(u, 1, 2);
        for(Rint v: T[u]){
            dfs(v);
            recolor(id[v], 2, 3);
            join(id[u], id[v]);
            connect(id[u], 2, 3);
            recolor(id[u], 3, 1);
        }
    }else{
        if(SZ(T[u]) == 1){
            Rint v = T[u][0];
            dfs(v), id[u] = id[v];
            return;
        }
        dfs(T[u][0]), id[u] = id[T[u][0]];
        dfs(T[u][1]);
        recolor(id[T[u][1]], 2, 4);
        join(id[u], id[T[u][1]]);
        connect(id[u], 2, 4);
        Rint tl = 4, nc = 3;
        //tail color, next color
        for(Rint v: T[u]) if(!id[v]){
            dfs(v);
            recolor(id[v], 2, nc);
            join(id[u], id[v]);
            connect(id[v], 3, 4);
            recolor(id[u], tl, 1);
            swap(tl, nc);
        }
        recolor(id[u], tl, 2);
    }
}

int main() {
    fin >> n >> m;
    FOR(i, 1, m){
        Rint k, u, v;
        fin >> k >> u;
        FOR(i, 1, k - 1){
            fin >> v;
            E[u].pb(v), E[v].pb(u);
            u = v;
        }
    }
    Tarjan::main();
    dfs(1);
    print_ans();
    return 0;
}
```
{% endfold %}

## G - Game on Graph

### 题意简述

一张有向图，两人`0`,`1`在玩游戏。游戏规则非常简单：图上有一棋子，两人轮流操作，每人每次将棋子沿当前位置的某条出边移动，不能动的人就输了。
但是由于一些特殊原因，`0`最希望游戏永远不要停止；若无法达到，其也会尽可能追求赢。`1`最不希望游戏永远不停止；若可以使游戏停止，其宁愿输。
现在请对于每个点作为棋子的开始点，每个人作为先手，求最后的状态是什么（赢/输/无法结束）。
$n\le 10^5, m\le 2\times 10^5$。

### 主要思路

设一个游戏状态为一个二元组 $(x, c)$ 表示当前棋子在点 $x$，此时操作的是 $c$。
`0`若`1`无论如何操作都可以使游戏无法结束，他就会令游戏无法结束；否则`1`会阻止游戏无法结束。
`1`若`0`无论如何操作都可以自己赢，那他会使自己赢；否则`0`会阻止`1`赢。
而其余的情况，`0`会赢。

考虑清楚这一点之后，就可以设 $ending(x, c), winning(x, c)$ 分别表示 $(x, c)$ 状态能否结束、`1`能否赢。

考虑用反向 bfs 来求 $ending$。
首先，显然对于所有没有出度的状态 $(x, c)$，它们均能结束。把这些状态全扔队列里。
考虑 $(x, 1)$ 如何能够结束：只要它的下一个可能状态中有一个可以结束，它就能结束；
而 $(x, 0)$ 要结束，必须要它的每一个下一个可能状态都可以结束。

同样用反向 bfs 来求 $winning$，可以发现转移方式完全一致。

### 参考代码

{% fold %}
```cpp
#include <bits/stdc++.h>
namespace my_std {
using namespace std;
#define reg register
#define Rint register int
#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)
#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)
typedef pair<int, int> PII;
typedef vector<int> VI;
#define pb emplace_back
#define fr first
#define sc second
#define MP make_pair
#define Templ(T) template <typename T>
Templ(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }
Templ(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }
} // namespace my_std
using namespace my_std;

#define MMR (1 << 23)
struct INPUT{
    FILE *F;
    char buf[MMR], *s, *t;
    INPUT(): F(fopen("game.in", "r")){
        t = (s = buf) + fread(buf, 1, MMR, F);
        fclose(F);
    }
    Templ(_Tp) inline INPUT& operator >>(_Tp &x){
        x = 0;
        reg char c(*s++);
        while(c < 48) c = *s++;
        while(c > 47) x = x * 10 + c - 48, c = *s++;
        return *this;
    }
}fin;
struct OUTPUT{
    FILE *F;
    char buf[MMR], *s;
    OUTPUT(): F(fopen("game.out", "w")){ s = buf; }
    inline OUTPUT& operator <<(int x){
        static int tmp[10];
        Rint *top = tmp;
        do{
            *++top = (x % 10) ^ 48, x /= 10;
        }while(x);
        while(top != tmp) *s++ = *top--;
        *s++ = 32;
        return *this;
    }
    inline OUTPUT& operator <<(char x){
        *s++ = x;
        return *this;
    }
    ~OUTPUT(){
        fwrite(buf, 1, s - buf, F);
        fclose(F);
    }
}fout;

//0: D - W - L
//1: W - L - D

#define N 100010
int n, m;
VI to[N], fm[N];
//正向边 / 反向边
int oud[N];

inline void init(){
    fin >> n >> m;
    Rint u, v;
    FOR(i, 1, m){
        fin >> u >> v;
        to[u].pb(v);
        fm[v].pb(u);
    }
}

queue<PII> Q;
inline void work(bool (*f)[2]){
    FOR(i, 1, n) oud[i] = to[i].size();
    FOR(i, 1, n) FOR(c, 0, 1) if(f[i][c]) Q.push(MP(i, c));
    while(!Q.empty()){
        PII now = Q.front();
        Q.pop();
        Rint u = now.fr;
        if(now.sc){
            for(int v: fm[u]) if(!f[v][0] && !--oud[v]){
                f[v][0] = 1;
                Q.push(MP(v, 0));
            }
        }else{
            for(int v: fm[u]) if(!f[v][1]){
                f[v][1] = 1;
                Q.push(MP(v, 1));
            }
        }
    }
}

bool endable[N][2], winning[N][2];
//endable[u][c]: 从 u 开始、c 先手时，1 是否能令其结束
//winning[u][c]: 从 u 开始、c 先手时，1 能否胜出

int main() {
    init();
    FOR(i, 1, n) if(to[i].empty())
        endable[i][0] = endable[i][1] = winning[i][0] = 1;
    work(endable);
    work(winning);
    FOR(i, 1, n){
        if(!endable[i][0]) fout << 'D';
        else if(winning[i][0]) fout << 'L';
        else fout << 'W';
    }
    fout << '\n';
    FOR(i, 1, n){
        if(winning[i][1]) fout << 'W';
        else if(endable[i][1]) fout << 'L';
        else fout << 'D';
    }
    return 0;
}
```
{% endfold %}

## K - Kids Designing Kids

## L - List of Primes

### 题意简述

## M - Mole Tunnels



### 题意简述

### 主要思路

### 参考代码

{% fold %}
{% endfold %}